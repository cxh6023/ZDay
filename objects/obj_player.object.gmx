<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_pistol</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Starting Variables
hp = 100;
maxHp = 100;
hpTime = 400; //How many frames it takes to restore a block(1/maxHp) of health
hpTimer = hpTime; //the actual variable that counts down, this represents the hpTime
player_speed = 2; //The speed of the player
player_boundary = 10; //The distance from the middle of the player to the edge of the boundaries
shotsfired = 0; //The amount of bullets fired in a certain amout of time(used to create bullet direction offset)
//offset = 5; //The amount of pixels the pistol accuracy will be chaged by every time you fire.
firing = true; //Variable to tell whether the player can/can't fire(true/false)
shotgunRange = 200;//Shotgun Range
placeHolder = 0; //Holds the player_boundary value, while it's decrementing
guns = 1; //this represents the amount of guns the player has
gun = 0; //this is the first variable in the weapon array, so the one represents the first weapon in the list of weapons
secondGun = 1; 
secondMag = 0;
secondAmmo = 0;
secondPapped = 0;
secondDamage = 0;
secondFiringCap = 0;
secondSemiAuto = 0;
secondOffset = 0;
papped = 0;
timer = 0;
randomGuns = 0;
boxTimer = 100; //how many frames the box leaves the gun open
papTimer = 60; //this is the timer for how long pack a punch takes
secondPapTimer = 120;
papStart = false;
shotColor = c_black;
points = 50000;
    //Knifing Variables
knifing = false;
knifed = false;
swingOffset = 90; //for knifing
    //Stamin-Up Soda Variables
runningTime = 20;
runningTimer = runningTime;
timeBetweenRuns = 200;
timerBetweenRuns = timeBetweenRuns;
    //Wave Variables
wave = 0; //this variable holds the current wave
activeZombies = 0; //this is the current amout of zombies in the room.
maxZombies = 0; //this is the maximum amount of zombies roaming at a time
waveZombies = 0; //this is the amout of zombies that will spawn per wave
zombiesLeft = waveZombies;
timeBetweenWaves = 200
waveTimer = timeBetweenWaves; //this is the time the player gets in between waves
    //Perk variables
drinking = false; //this represnts whether the character is drinking a perk or not
drinkTime = 60;
drinkTimer = drinkTime;
perk = 0; //which perk you are currently drinking 1 is jugg, 2 is speed
perks = 0; //this variable stores the amoutn of perks the player is holding
perkNames[0] = spr_blank;
perkNames[1] = spr_blank;
perkNames[2] = spr_blank;
perkNames[3] = spr_blank;
/*
*This can be used to show if we are placing a second one(if mineCount doesn't evenly go into 2)
*This also works vise versa to see if we haven't placed one yet
*/

globalvar shotx;
globalvar shoty;
//First Shot
globalvar endx;
globalvar endy;
//Second Shot
globalvar endx1;
globalvar endy1;
//Third Shot
globalvar endx2;
globalvar endy2;
//Fourth Shot
globalvar endx3;
globalvar endy3;
//Fifth Shot
globalvar endx4;
globalvar endy4;

lastHMovement = 0;
lastVMovement = 0;
lastX = 0;
lastY = 0;

//Weapons [weapon number[weapon name(0), weapon magazine size(1), weapon ammunition size(2), weapon box frames(3), weapon ceasefire(4), weapon firing(5), weapon damage(6), firing cap(7), auto/semi(8), offset(9)]]
//COLT M1911
weapon[0, 0]= "Colt M1911";
weapon[0, 1]= 8;
weapon[0, 2]= 80;
weapon[0, 3]= spr_mystery_box1;
weapon[0, 4]= spr_player_pistol_ceasefire;
weapon[0, 5]= spr_player_pistol;
weapon[0, 6]= 1; //damage
weapon[0, 7]= 0; //cap
weapon[0, 8]= 0; //auto/semi
weapon[0, 9]= 5; //offset
weapon[0, 10]= 50; //reloadTimer

weapon[1, 0]= "Colt 45 &amp; Two Zig-Zags"; //this is the name of the packed Colt M1911
weapon[1, 1]= 20;
weapon[1, 2]= 140;
weapon[1, 3]= spr_mystery_box1;
weapon[1, 4]= spr_player_pistol_packed_ceasefire;
weapon[1, 5]= spr_player_pistol_packed;
weapon[1, 6]= 15; 
weapon[1, 7]= 0;
weapon[1, 8]= 0;
weapon[1, 9]= 5; //offset
weapon[1, 10]= 50; //reloadTimer
//REMINGTON 870 MCS
weapon[2, 0]= "Remington 870MCS";
weapon[2, 1]= 3;
weapon[2, 2]= 36;
weapon[2, 3]= spr_mystery_box2;
weapon[2, 4]= spr_player_r870_ceasefire;
weapon[2, 5]= spr_player_r870;
weapon[2, 6]= 2;
weapon[2, 7]= 15;
weapon[2, 8]= 0;
weapon[2, 9]= 0; //offset
weapon[2, 10]= 50; //reloadTimer

weapon[3, 0]= "And On the Third Day...";
weapon[3, 1]= 12;
weapon[3, 2]= 90;
weapon[3, 3]= spr_mystery_box2;
weapon[3, 4]= spr_player_r870_packed_ceasefire;
weapon[3, 5]= spr_player_r870_packed;
weapon[3, 6]= 4;
weapon[3, 7]= 15;
weapon[3, 8]= 0;
weapon[3, 9]= 5; //offset
weapon[3, 10]= 50; //reloadTimer
//Ray Gun
weapon[4, 0]= "Ray Gun";
weapon[4, 1]= 20;
weapon[4, 2]= 200;
weapon[4, 3]= spr_mystery_box3;
weapon[4, 4]= spr_player_rayGun_ceasefire;
weapon[4, 5]= spr_player_rayGun;
weapon[4, 6]= 20;
weapon[4, 7]= 50;
weapon[4, 8]= 0;
weapon[4, 9]= 0; //offset
weapon[4, 10]= 50; //reloadTimer

weapon[5, 0]= "Porter's X2 Ray Gun";
weapon[5, 1]= 40;
weapon[5, 2]= 400;
weapon[5, 3]= spr_mystery_box3;
weapon[5, 4]= spr_player_rayGun_packed_ceasefire;
weapon[5, 5]= spr_player_rayGun_packed;
weapon[5, 6]= 30;
weapon[5, 7]= 5;
weapon[5, 8]= 0;
weapon[5, 9]= 0; //offset
weapon[5, 10]= 50; //reloadTimer
//Galil
weapon[6, 0]= "Galil"; //name
weapon[6, 1]= 24; //mag size
weapon[6, 2]= 120; //ammo
weapon[6, 3]= spr_mystery_box4; //box animation
weapon[6, 4]= spr_player_galil_ceasefire; //ceasefire animation
weapon[6, 5]= spr_player_galil; //gun animation
weapon[6, 6]= 4; //weapon damage
weapon[6, 7]= 4; //firing cap by frame //was 3
weapon[6, 8]= 1; //semi/auto
weapon[6, 9]= 1; //offset //orinal was 1
weapon[6, 10]= 50; //reloadTimer

weapon[7, 0]= "HagerBanger"; //name
weapon[7, 1]= 48; //mag size
weapon[7, 2]= 240; //ammo
weapon[7, 3]= spr_mystery_box4; //box animation
weapon[7, 4]= spr_player_galil_packed_ceasefire; //ceasefire animation
weapon[7, 5]= spr_player_galil_packed; //gun animation
weapon[7, 6]= 8; //weapon damage
weapon[7, 7]= 4; //firing cap by frame //was 3
weapon[7, 8]= 1; //semi/auto
weapon[7, 9]= 1; //offset //orinal was 1
weapon[7, 10]= 30; //reloadTimer
//RPD
weapon[8, 0]= "RPD"; //name
weapon[8, 1]= 100; //mag size
weapon[8, 2]= 360; //ammo
weapon[8, 3]= spr_mystery_box5; //box animation
weapon[8, 4]= spr_player_rpd_ceasefire; //ceasefire animation
weapon[8, 5]= spr_player_rpd; //gun animation
weapon[8, 6]= 6; //weapon damage
weapon[8, 7]= 6; //firing cap by frame //was 3
weapon[8, 8]= 1; //semi/auto
weapon[8, 9]= 1; //offset //orinal was 1
weapon[8, 10]= 100; //reloadTimer

weapon[9, 0]= "Respiratory Puking Disorder"; //name
weapon[9, 1]= 200; //mag size
weapon[9, 2]= 400; //ammo
weapon[9, 3]= spr_mystery_box5; //box animation
weapon[9, 4]= spr_player_rpd_packed_ceasefire; //ceasefire animation
weapon[9, 5]= spr_player_rpd_packed; //gun animation
weapon[9, 6]= 8; //weapon damage
weapon[9, 7]= 6; //firing cap by frame //was 3
weapon[9, 8]= 1; //semi/auto
weapon[9, 9]= 1; //offset //orinal was 1
weapon[9, 10]= 75; //reloadTimer
//Uzi
weapon[10, 0]= "Uzi"; //name
weapon[10, 1]= 20; //mag size
weapon[10, 2]= 100; //ammo
weapon[10, 3]= spr_mystery_box6; //box animation
weapon[10, 4]= spr_player_uzi_ceasefire; //ceasefire animation
weapon[10, 5]= spr_player_uzi; //gun animation
weapon[10, 6]= 2; //weapon damage
weapon[10, 7]= 2; //firing cap by frame //was 3
weapon[10, 8]= 1; //semi/auto
weapon[10, 9]= 5; //offset //orinal was 1
weapon[10, 10]= 20; //reloadTimer

weapon[11, 0]= "Zoo-Wee-Mama!"; //name
weapon[11, 1]= 32; //mag size
weapon[11, 2]= 200; //ammo
weapon[11, 3]= spr_mystery_box6; //box animation
weapon[11, 4]= spr_player_uzi_packed_ceasefire; //ceasefire animation
weapon[11, 5]= spr_player_uzi_packed; //gun animation
weapon[11, 6]= 6; //weapon damage
weapon[11, 7]= 2; //firing cap by frame //was 3
weapon[11, 8]= 1; //semi/auto
weapon[11, 9]= 4; //offset //orinal was 1
weapon[11, 10]= 10; //reloadTimer
//Python
weapon[12, 0]= "Python"; //name
weapon[12, 1]= 1; //mag size
weapon[12, 2]= 8; //ammo
weapon[12, 3]= spr_mystery_box7; //box animation
weapon[12, 4]= spr_player_python_ceasefire; //ceasefire animation
weapon[12, 5]= spr_player_python; //gun animation
weapon[12, 6]= 12; //weapon damage
weapon[12, 7]= 3; //firing cap by frame //was 3
weapon[12, 8]= 1; //semi/auto
weapon[12, 9]= 1; //offset //orinal was 1
weapon[12, 10]= 20; //reloadTimer

weapon[13, 0]= "Cobra"; //name
weapon[13, 1]= 2; //mag size
weapon[13, 2]= 16; //ammo
weapon[13, 3]= spr_mystery_box7; //box animation
weapon[13, 4]= spr_player_python_packed_ceasefire; //ceasefire animation
weapon[13, 5]= spr_player_python_packed; //gun animation
weapon[13, 6]= 18; //weapon damage
weapon[13, 7]= 3; //firing cap by frame //was 3
weapon[13, 8]= 1; //semi/auto
weapon[13, 9]= 1; //offset //orinal was 1
weapon[13, 10]= 20; //reloadTimer

cycleGuns = 0; //this variable is used for cycling through all of the guns that are available.
gunsInBox = 7; //this is the amount of guns that are in the box minus 1
sprite_ceasefire = weapon[gun+papped, 4]; //This variable is supposed to change according to the gun you have
sprite_not_ceasefire = weapon[gun+papped, 5]; //This variable is supposed to change according to the gun you have
randomGun = 0; //thsi is for testing //ignore
magazine = weapon[gun+papped, 1]; //the amout of bullets currently in the player's magazine
ammo = weapon[gun+papped, 2]; //the amount of ammunition the player is storing currently
firingCap = weapon[gun+papped, 7]; //this sets the firing cap
capCounter = firingCap;
secondFiringCap = 0;
reloadingTimer = weapon[gun+papped, 10];
reloading = false;
//The direction from the player to the mouse origin
globalvar dir;
dir = point_direction(x, y, mouse_x, mouse_y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Moving &amp; Moving Animation
w = keyboard_check(ord("W"))*-1;
s = keyboard_check(ord("S"));
a = keyboard_check(ord("A"))*-1;
d = keyboard_check(ord("D"));
///Collision
h_movement = (a+d)*player_speed;
v_movement = (w+s)*player_speed;

//Movement animation
if(h_movement != 0 &amp;&amp; v_movement != 0)
{
    if(!knifing)
    image_speed = 1;
}
else
{
    if(!knifing)
    image_speed = 0;
}
var h_startCountR = collision_rectangle(x, y-player_boundary, (x+player_boundary) + h_movement, y+player_boundary, obj_wall_metal, 0, 0) || 
    collision_rectangle(x, y-player_boundary, (x+player_boundary) + h_movement, y+player_boundary, obj_explodables, 0, 0);
var h_startCountL = collision_rectangle((x-player_boundary) + h_movement, y-player_boundary, x, y+player_boundary, obj_wall_metal, 0, 0) || 
    collision_rectangle((x-player_boundary) + h_movement, y-player_boundary, x, y+player_boundary, obj_explodables, 0, 0);
//Horizontal Collision
var h_countMovement = h_movement;
if(h_countMovement &lt; 0)
{
    while(h_startCountL &amp;&amp; h_countMovement &lt; 0) //If I'm going to collide with something
    {
        h_countMovement++;
        var h_startCountL = collision_rectangle((x-player_boundary) + h_countMovement, y-player_boundary, x, y+player_boundary, obj_wall_metal, 0, 0) ||
        collision_rectangle((x-player_boundary) + h_countMovement, y-player_boundary, x, y+player_boundary, obj_explodables, 0, 0);
    }
}
if(h_countMovement &gt; 0)
{
    while(h_startCountR &amp;&amp; h_countMovement &gt; 0) //If I'm going to collide with something
    {
        h_countMovement--;
        var h_startCountR = collision_rectangle(x, y-player_boundary, (x+player_boundary) + h_countMovement, y+player_boundary, obj_wall_metal, 0, 0) ||
        collision_rectangle(x, y-player_boundary, (x+player_boundary) + h_countMovement, y+player_boundary, obj_explodables, 0, 0);
    }
}

var v_startCountD = collision_rectangle(x-player_boundary, y, x+player_boundary, (y+player_boundary) + v_movement, obj_wall_metal, 0, 0) || 
    collision_rectangle(x-player_boundary, y, x+player_boundary, (y+player_boundary) + v_movement, obj_explodables, 0, 0);
var v_startCountU = collision_rectangle(x-player_boundary, (y-player_boundary) + v_movement, x+player_boundary, y, obj_wall_metal, 0, 0) || 
    collision_rectangle(x-player_boundary, (y-player_boundary) + v_movement, x+player_boundary, y, obj_explodables, 0, 0);
//Vertical Collision
var v_countMovement = v_movement;
if(v_countMovement &lt; 0)
{
    while(v_startCountU &amp;&amp; v_countMovement &lt; 0) //If I'm going to collide with something
    {
        v_countMovement++;
        var v_startCountU = collision_rectangle(x-player_boundary, (y-player_boundary) + v_countMovement, x+player_boundary, y, obj_wall_metal, 0, 0) ||
            collision_rectangle(x-player_boundary, (y-player_boundary) + v_countMovement, x+player_boundary, y, obj_explodables, 0, 0);
    }
}
if(v_countMovement &gt; 0)
{
    while(v_startCountD &amp;&amp; v_countMovement &gt; 0) //If I'm going to collide with something
    {
        v_countMovement--;
        var v_startCountD = collision_rectangle(x-player_boundary, y, x+player_boundary, (y+player_boundary) + v_countMovement, obj_wall_metal, 0, 0) ||
            collision_rectangle(x-player_boundary, y, x+player_boundary, (y+player_boundary) + v_countMovement, obj_explodables, 0, 0);
    }
}
x+=h_countMovement;
y+=v_countMovement;
//Sprint Management
/*
runningTime = 30;
runningTimer = runningTime;
timeBetweenRuns = 60;
timerBetweenRuns = timeBetweenRuns;
*/
if(keyboard_check(vk_space) &amp;&amp; runningTimer &gt;= 0 &amp;&amp; timerBetweenRuns &lt;= 0) //and you can sprint
{
    player_speed = 4;
    runningTimer--;
    if(runningTimer &lt;= 0)
    {
        timerBetweenRuns = timeBetweenRuns;
        player_speed = 2;
    }
}    
if(keyboard_check_released(vk_space))
{
    runningTimer = runningTime;
    player_speed = 2;
}
if(player_speed == 2)
{
    timerBetweenRuns--;
}
//New code ends here
//Adjusts the player position to face your mouse
image_angle = point_direction(x, y, mouse_x, mouse_y)-90;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Single Shot Accuracy Management
if(mouse_check_button_pressed(mb_left) || mouse_check_button(mb_left))
{    
    if(timer == 0)
    {
        shotsfired = 0;
        timer = 30;
    }
    else
    {
        if(shotsfired &lt; 4)
            shotsfired = shotsfired + 1;
        timer = 30;
    }
    //Creates the explosion object
    //instance_create(x+lengthdir_x(27, dir), y+lengthdir_y(27, dir), obj_fire);
}
if(random(1) &lt;= .5)
    left_right = 1;
else
    left_right = -1;
    
if(timer &gt; 0)
    timer = timer - 1;
    //The direction from the player to the mouse origin
globalvar dir;
dir = point_direction(x, y, mouse_x, mouse_y);
//The direction from the shot origin and mouse origin
globalvar dir1;
dir1 = point_direction(x+lengthdir_x(20, dir-15), y+lengthdir_y(20, dir-15), mouse_x, mouse_y) + (weapon[gun+papped, 9]*shotsfired*left_right);

/*
///Single Shot Accuracy Management
if(gun == 0)
{
if(mouse_check_button_pressed(mb_left))
{    
    if(timer == 0)
    {
        shotsfired = 0;
        timer = 30;
    }
    else
    {
        if(shotsfired &lt; 4)
            shotsfired = shotsfired + 1;
        timer = 30;
    }
    //Creates the explosion object
    //instance_create(x+lengthdir_x(27, dir), y+lengthdir_y(27, dir), obj_fire);
}
if(random(1) &lt;= .5)
    left_right = 1;
else
    left_right = -1;
    
if(timer &gt; 0)
    timer = timer - 1;
}
    //The direction from the player to the mouse origin
globalvar dir;
dir = point_direction(x, y, mouse_x, mouse_y);
if(gun == 0)
{
if(mouse_check_button_pressed(mb_left))
{
//The direction from the shot origin and mouse origin
globalvar dir1;
dir1 = point_direction(x+lengthdir_x(20, dir-15), y+lengthdir_y(20, dir-15), mouse_x, mouse_y) + (offset*shotsfired*left_right);
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Multi Shot Accuracy Management
if(gun == 2 || gun == 3) //this code is only run when you do not have the starting gun or the starting packed
{
    if(mouse_check_button(mb_left))
    {
        //The direction from the player to the mouse origin
        globalvar dir;
        dir = point_direction(x, y, mouse_x, mouse_y);
        //The direction from the shot origin and mouse origin
        globalvar dir1; 
        dir1 = point_direction(x+lengthdir_x(20, dir-15), y+lengthdir_y(20, dir-15), mouse_x, mouse_y);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Shooting
if(weapon[gun+papped, 8] == 0) //if the gun is semi 
//FIRING CAP IS NOT SETUP FOR SEMI WEAPONS YET!
{
if(mouse_check_button_pressed(mb_left) &amp;&amp; !ceasefire)
{
    if(gun == 0) //if the colt m1911 is equipped
    {
        if(magazine &gt; 0) //if you have bullets in your magazine
        {
            scr_hitScan(-15); //fire the gun
        }
    } 
    if(gun == 2) //if the remington is equipped
    {
        if(magazine &gt; 0) //if you have bullets in your magazine
        {
            shotCoordinate = scr_multiHitScan(-15, 4,2); //fire the gun
            //show_message(string(shotCoordinate[0]) + ", " + string(shotCoordinate[1]) + ", " + string(shotCoordinate[2]) + ", " + string(shotCoordinate[3]) + ", " + string(shotCoordinate[4])+ ", " + string(shotCoordinate[5]));
        }
    } 
    if(gun == 4 || gun == 5) //if the ray gun is equipped
    {
        if(magazine &gt; 0) //if you have bullets in your magazine
        {
            instance_create(x+lengthdir_x(20, dir-15), y+lengthdir_y(20, dir-15), obj_ray);
            magazine--;
        }
    } 
}
}
if(weapon[gun+papped, 8] == 1) //if the gun is automatic
{
    if(capCounter &gt; 0)
        capCounter--;
    if(capCounter == 0 &amp;&amp; magazine &gt; 0 &amp;&amp; mouse_check_button(mb_left))
    { 
        scr_hitScan(-15); //fire the gun
    }
}
    /*
        //This makes the middle left shot:
            //Creates a variable(endx)
            endx1 = shotx
            //Creates a variable(endy)
            endy1 = shoty;
            var collision = position_meeting(endx1, endy1, obj_wall_metal);
            while(!collision &amp;&amp; distance_to_point(endx1, endy1) &lt; room_width)
            {
                endx1 += lengthdir_x(1, dir1-5)
                endy1 += lengthdir_y(1, dir1-5)
                collision = position_meeting(endx1, endy1, obj_wall_metal);
            }
            
        //This makes the far left shot:
            //Creates a variable(endx)
            endx2 = shotx
            //Creates a variable(endy)
            endy2 = shoty;
            var collision = position_meeting(endx2, endy2, obj_wall_metal);
            while(!collision &amp;&amp; distance_to_point(endx2, endy2) &lt; room_width)
            {
                endx2 += lengthdir_x(1, dir1-10)
                endy2 += lengthdir_y(1, dir1-10)
                collision = position_meeting(endx2, endy2, obj_wall_metal);
            }
            
        //This makes the middle right shot:
            //Creates a variable(endx)
            endx3 = shotx
            //Creates a variable(endy)
            endy3 = shoty;
            var collision = position_meeting(endx3, endy3, obj_wall_metal);
            while(!collision &amp;&amp; distance_to_point(endx3, endy3) &lt; room_width)
            {
                endx3 += lengthdir_x(1, dir1+5)
                endy3 += lengthdir_y(1, dir1+5)
                collision = position_meeting(endx3, endy3, obj_wall_metal);
                            
            }
            
        //This makes the far right shot:
            //Creates a variable(endx)
            endx4 = shotx
            //Creates a variable(endy)
            endy4 = shoty;
            var collision = position_meeting(endx4, endy4, obj_wall_metal);
            while(!collision &amp;&amp; distance_to_point(endx4, endy4) &lt; room_width)
            {
                endx4 += lengthdir_x(1, dir1+10)
                endy4 += lengthdir_y(1, dir1+10)
                collision = position_meeting(endx4, endy4, obj_wall_metal);
            }
            */
  //  }
//}
//}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CeaseFire
//Explodable object boundaries
explodables = 
collision_line(x+lengthdir_x(7, dir+90), y+lengthdir_y(7, dir+90), x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14), obj_explodables, 0, 1) || 
collision_line(x+lengthdir_x(7, dir+270), y+lengthdir_y(7, dir+270),x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14), obj_explodables, 0, 1);
//Using Stairs
/*
stairsUp = 
collision_line(x+lengthdir_x(7, dir+90), y+lengthdir_y(7, dir+90), x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14), obj_stairs_up, 0, 1) || 
collision_line(x+lengthdir_x(7, dir+270), y+lengthdir_y(7, dir+270),x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14), obj_stairs_up, 0, 1);
*/
/*
stairsDown = 
collision_line(x+lengthdir_x(7, dir+90), y+lengthdir_y(7, dir+90), x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14), obj_stairs_down, 0, 1) || 
collision_line(x+lengthdir_x(7, dir+270), y+lengthdir_y(7, dir+270),x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14), obj_stairs_down, 0, 1);
*/
/*
//Using Triangle HitBox
x+lengthdir_x(7, dir+90), y+lengthdir_y(7, dir+90), //Left Point
x+lengthdir_x(7, dir+270), y+lengthdir_y(7, dir+270), //Rigt Point
x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14), 1); //Front Point
*/
//ceasefire checks whether the player needs to be in a ceasefire position
if(!drinking &amp;&amp; !reloading)
{
    ceasefire = 
    collision_line(x+lengthdir_x(7, dir+90), y+lengthdir_y(7, dir+90), x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14), obj_wall_metal, 0, 1) || 
    collision_line(x+lengthdir_x(7, dir+270), y+lengthdir_y(7, dir+270),x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14), obj_wall_metal, 0, 1) || 
    explodables;
}

//These two if statements are to adjust the player's image depending on the gun they have
sprite_ceasefire = weapon[gun+papped, 4]; //This variable is supposed to change according to the gun you have
sprite_not_ceasefire = weapon[gun+papped, 5]; //This variable is supposed to change according to the gun you have
if(!knifing) //only switch the sprites if you're not knifing
{
if(ceasefire)
{
    sprite_index = sprite_ceasefire;
}
if(!ceasefire)
{
    sprite_index = sprite_not_ceasefire;
}
if(guns == 0)
{
    ceasefire = true;
    sprite_index = spr_player_ceasefire;
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Using the Mystery Box
randomize(); //makes sure the random numbers generated are actually random
if(collision_rectangle(obj_mystery_box.x-6, obj_mystery_box.y, obj_mystery_box.x+54, obj_mystery_box.y+20, obj_player, 0, 0)) //if you're next to the box
{
    draw_text(100, 100, "Hold [F] for Mystery Box(950)");
//PRESS F/OPEN BOX
    if(keyboard_check_pressed(ord("F")) &amp;&amp; points &gt;= 950 &amp;&amp; papStart == false &amp;&amp; obj_mystery_box.image_speed == 0 &amp;&amp; obj_mystery_box.image_index == 0) //if you're pressing F
    {
        obj_mystery_box.image_speed = 1;
        points-=950;
    }
}
    if(obj_mystery_box.image_index == 10 &amp;&amp; cycleGuns&lt;gunsInBox) //if the animation is done
    {
        randomGun = round(random_range(0, gunsInBox*2-1)); //the random number has to be even, because odd numbers represent pack-a-punched guns
        if(guns == 1)
        {
            while(randomGun == gun || randomGun%2 != 0)
            {
                randomGun = round(random_range(0, gunsInBox*2-1));    
            }
        }
        if(guns == 2)
        {
            while(randomGun == gun || randomGun == secondGun || randomGun%2 != 0)
            {
                randomGun = round(random_range(0, gunsInBox*2-1));    
            }
        }
        obj_mystery_box.sprite_index = weapon[randomGun+papped, 3]; //switch to the next gun box animation
        obj_mystery_box.image_index = 0;
        cycleGuns++;
    }

//LEAVE THE GUN TILL THE ALARM GOES OFF
    if(obj_mystery_box.image_index == 10 &amp;&amp; cycleGuns==gunsInBox) //if all the gun animations are done
    {
        //Make the box stay as the gun 
        boxTimer -= 1; //count down the time that the gun is available
        obj_mystery_box.image_speed = 0;
        //Make the box stay as the gun
        
        //"HOLD "F" FOR WEAPON"
        if(keyboard_check_pressed(ord("F")))    
        {
            if(guns == 1) //if the player only has one gun
            {
                guns++;
                var placeHolderGun = gun;
                var placeHolderMag = magazine;
                var placeHolderAmmo = ammo;
                var placeHolderPapped = papped;
                var placeHolderFiringCap = firingCap
                gun = randomGun; //this sets the current gun in the inventory to the gun in the box 
                papped = 0; //sets the new gun to not be a packed gun
                magazine = weapon[randomGun, 1]; //getting the box gun
                ammo = weapon[randomGun, 2]; //getting the box gun  
                firingCap = weapon[randomGun, 7];          
                secondGun = placeHolderGun; //making the second gun your original gun
                secondMag = placeHolderMag; //making the second gun your original gun
                secondAmmo = placeHolderAmmo; //making the second gun your original gun
                secondPapped = placeHolderPapped; //making the second gun your original gun
                secondFiringCap = placeHolderFiringCap;
            }
            if(guns == 2) //if the player has two guns gun
            {
                gun = randomGun; //this sets the current gun in the inventory to the gun in the box
                papped = 0;
                magazine = weapon[gun, 1];
                ammo = weapon[gun, 2];
                firingCap = weapon[gun, 7];   
            }
            /*
            gun = randomGun; //this sets the current gun in the inventory to the gun in the box
            magazine = weapon[gun, 1];
            ammo = weapon[gun, 2];
            */
            boxTimer = 0; //this makes sure that when the gun is chosen the box closes.
        }
    }
//WHEN THE TIMER IS UP, CLOSE THE BOX
    if(boxTimer == 0)
    {
        //show_message("close the box");
        obj_mystery_box.sprite_index = spr_mystery_box; //switch to closing box animation
        obj_mystery_box.image_index = 10;
        obj_mystery_box.image_speed = -1; //make the animation play backwards(to give the illusion of closing) 
        boxTimer =   100; 
    }
//WHEN THE BOX IS CLOSED STOP ALL ANIMATIONS AND MAKE IT INANIMATE
    if(obj_mystery_box.image_speed == -1 &amp;&amp; obj_mystery_box.image_index == 0)
    {   
        //show_message("The box should stop moving") //this was to notify when the box should be inanimate for testing purposes
        obj_mystery_box.image_speed = 0;
        cycleGuns = 0;
    }
/*
//WHEN THE BOX IS CLOSED STOP ALL ANIMATIONS AND MAKE IT INANIMATE
    if(obj_mystery_box.image_index == 0 &amp;&amp; obj_mystery_box.image_speed == -1)
    {   
        show_message("The box should stop moving")
        obj_mystery_box.image_speed = 0;
        cycleGuns = 0;
    }
}
*/
    /*
    if(obj_mystery_box.image_index == 0 &amp;&amp; cycleGuns==gunsInBox) //if the closing box animation is done
    {
        obj_mystery_box.sprite_index = spr_mystery_box; //switch to closing box animation
        obj_mystery_box.image_index = 0; //set the animation frame to 0
        obj_mystery_box.image_speed = 0; //set the animation speed to 0
        cycleGuns = 0;
    }
    */
   /*
     if(obj_mystery_box.image_speed == 1)
    {
        if(obj_mystery_box.image_index == 5 &amp;&amp; cycleGuns &lt; gunsInBox)
        {
            obj_mystery_box.sprite_index = weapon[cycleGuns, 3];
            image_index = 0; //start the new animation at the 1st frame
            cycleGuns++;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Using Pack-A-Punch
//Counting Down till its done packing
if(papStart == true &amp;&amp; papStart &gt; 0) //if you started to use PAP
{
    papTimer--;
}
if(papTimer &lt;= 0 &amp;&amp; papStart == true) //if PAP is done cooking
{
obj_pack_a_punch.image_index = 5; //sets the pap machine to the second frame
obj_pack_a_punch.image_speed = 0; //stops the pap machine from animating
secondPapTimer--;

if(collision_rectangle(obj_pack_a_punch.x-6, obj_pack_a_punch.y, obj_pack_a_punch.x+70, obj_pack_a_punch.y+40, obj_player, 0, 0))
{
    if(keyboard_check_pressed(ord("F")) &amp;&amp; secondPapTimer &gt; 0)
    {
        guns++;
        //Return the pack-a-punched gun
        secondPapped = 1; //makes the second gun packed because the gun received from pack a punch goes to the second slot, then is switched
        secondGun = papGun; //sets the papped gun to the secondary weapon slot
        secondMag = weapon[papGun+secondPapped, 1]; //sets the papped gun magazine to the secondary weapon slot
        secondAmmo = weapon[papGun+secondPapped, 2]; //sets the papped gun ammunition to the secondary weapon slot
        secondDamage = weapon[papGun+secondPapped, 6]; //sets the papped gun damage to the secondary weapon slot
        secondFiringCap = weapon[papGun+secondPapped, 7]; //sets the papped guns firing cap to the secondary weapon slot
        secondSemiAuto = weapon[papGun+secondPapped, 8]; //sets the papped gun semi/auto variable to the secondary weapon slot
        secondOffset = weapon[papGun+secondPapped, 9]; //sets the papped gun
        //secondGun = ; //one hundred represents when the user doesn't 2 guns
        scr_switchWeapons(); //switches the weapons
        show_message("Here is your packed Gun" + string(weapon[gun+papped, 0]));
        papTimer = 60;//Reset the first timer
        secondPapTimer = 120; //Reset the second timer
        papStart = false; //resetting the pap variable 
        obj_pack_a_punch.image_index = 0;
    }
}
}
if(collision_rectangle(obj_pack_a_punch.x-6, obj_pack_a_punch.y, obj_pack_a_punch.x+70, obj_pack_a_punch.y+40, obj_player, 0, 0) &amp;&amp; papStart == false) //if you're next to PAP
{
//PRESS F/OPEN PAP
    if(keyboard_check_pressed(ord("F")) &amp;&amp; points &gt;= 5000 &amp;&amp; papStart == false) //if you're pressed F
    {
        points-=5000;
        //show_message("Pap Started");
        obj_pack_a_punch.image_speed = 1;
        if(guns == 1) //if you have one gun
        {
            papGun = gun; //this saves the gun that is being packed
            papStart = true;
            guns = 0; //makes sure the user has a gun taken away for the time of packing
        }
        if(guns == 2) //if you have two guns
        {
            papGun = gun; //this saves the gun that is being packed
            scr_switchWeapons();
            papStart = true;
            guns = 1; //makes sure the user has a gun taken away for the time of packing
        }
    }
}
/*
///Using the Mystery Box
randomize(); //makes sure the random numbers generated are actually random
if(collision_rectangle(obj_mystery_box.x-6, obj_mystery_box.y, obj_mystery_box.x+54, obj_mystery_box.y+20, obj_player, 0, 0)) //if you're next to the box
{
    draw_text(100, 100, "Hold [F] for Mystery Box");
//PRESS F/OPEN BOX
    if(keyboard_check_pressed(ord("F"))) //if you're pressing F
    {
        obj_mystery_box.image_speed = 1;
    }
}
    if(obj_mystery_box.image_index == 10 &amp;&amp; cycleGuns&lt;gunsInBox) //if the animation is done
    {
        randomGun = round(random_range(0, gunsInBox-1));
        if(guns == 1)
        {
            while(randomGun == gun)
            {
                randomGun = round(random_range(0, gunsInBox-1));    
            }
        }
        if(guns == 2)
        {
            while(randomGun == gun || randomGun == secondGun)
            {
                randomGun = round(random_range(0, gunsInBox-1));    
            }
        }
        obj_mystery_box.sprite_index = weapon[randomGun, 3]; //switch to the next gun box animation
        obj_mystery_box.image_index = 0;
        cycleGuns++;
    }

//LEAVE THE GUN TILL THE ALARM GOES OFF
    if(obj_mystery_box.image_index == 10 &amp;&amp; cycleGuns==gunsInBox) //if all the gun animations are done
    {
        //Make the box stay as the gun 
        boxTimer -= 1; //count down the time that the gun is available
        obj_mystery_box.image_speed = 0;
        //Make the box stay as the gun
        
        //"HOLD "F" FOR WEAPON[cycleGuns, 0]"
        if(keyboard_check_pressed(ord("F")))    
        {
            if(guns == 1) //if the player only has one gun
            {
                guns++;
                var placeHolderGun = gun;
                var placeHolderMag = magazine;
                var placeHolderAmmo = ammo;
                gun = randomGun; //this sets the current gun in the inventory to the gun in the box
                magazine = weapon[gun, 1];
                ammo = weapon[gun, 2];
                secondGun = placeHolderGun;
                secondMag = placeHolderMag;
                secondAmmo = placeHolderAmmo;
            }
            if(guns == 2) //if the player only has one gun
            {
                gun = randomGun; //this sets the current gun in the inventory to the gun in the box
                magazine = weapon[gun, 1];
                ammo = weapon[gun, 2];
            }
            /*
            gun = randomGun; //this sets the current gun in the inventory to the gun in the box
            magazine = weapon[gun, 1];
            ammo = weapon[gun, 2];
            boxTimer = 0; //this makes sure that when the gun is chosen the box closes.
        }
    }
//WHEN THE TIMER IS UP, CLOSE THE BOX
    if(boxTimer == 0)
    {
        //show_message("close the box");
        obj_mystery_box.sprite_index = spr_mystery_box; //switch to closing box animation
        obj_mystery_box.image_index = 10;
        obj_mystery_box.image_speed = -1; //make the animation play backwards(to give the illusion of closing) 
        boxTimer =   100; 
    }
//WHEN THE BOX IS CLOSED STOP ALL ANIMATIONS AND MAKE IT INANIMATE
    if(obj_mystery_box.image_speed == -1 &amp;&amp; obj_mystery_box.image_index == 0)
    {   
        //show_message("The box should stop moving") //this was to notify when the box should be inanimate for testing purposes
        obj_mystery_box.image_speed = 0;
        cycleGuns = 0;
    }
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reloading

reloadTime = weapon[gun+papped, 10];
//weapon[gun, 1] - total magazine size; 
//weapon[gun, 2] - total ammunition start;
ammoNeeded = weapon[gun+papped, 1] - magazine;
//original
//ammoNeeded = weapon[gun, 1] - magazine;
//original
if(keyboard_check(ord("R")) &amp;&amp; (ammoNeeded &gt; 0)) //if R is pressed and your magazine is not full 
{
    reloading = true;         
}
if(reloading) //if the character was reloading
{
    reloadingTimer--;
    ceasefire = true;
    if(reloadingTimer &lt;= 0)
    {
        if(ammoNeeded &gt; ammo) //if you need more ammo then you have
        {
            while(ammo &gt; 0)
            {
                ammo--;
                magazine++
            }
            reloadingTimer = reloadTime;
            reloading = false;
        }
        else
        {
            ammo-=ammoNeeded; //subtract ammoNeeded from your total ammo supply
            magazine+=ammoNeeded; //add the ammo taken from the supply to the magazine
            reloadingTimer = reloadTime;
            reloading = false;
        } 
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Switching Guns
if(keyboard_check_pressed(ord("Q"))) //if you're pressing Q
{
    if(guns &gt; 1) //if you have more than one gun
    {
        //show_message("You have more than one gun");
        scr_switchWeapons(); //this switches weapons    
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Wave Incrementation/Management
if(zombiesLeft &lt;= 0 || wave == 0)
{
    waveTimer--;
}
if(waveTimer &lt;= 0)
{
    audio_play_sound(snd_rnd_start, 0, 0);
    wave++; //increment the wave variable
    waveTimer = timeBetweenWaves;
    activeZombies = 0; //this is the current amout of zombies in the room.
    maxZombies = 4+(2*wave); //this is the maximum amount of zombies roaming at a time
    waveZombies = 4+(4*wave); //this is the amout of zombies that will spawn per wave
    zombiesLeft = waveZombies;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Health Management
if(hp &lt; maxHp) //if the player has taken damage
{
    if(hpTimer &lt;= hpTime) 
    {
        hpTimer = hpTime
        hp++;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Perk Management
if(drinking) //if the player is drinking a perk
{
    drinkTimer--; //decrement the drink timer variable
    ceasefire = true; //cannot fire a gun
    if(drinkTimer &lt;= 0) //if the player has finished drinking the perk
    {
        drinking = false; //the player is no longer dirnkin
        ceaseFire = false; //the player can use his weapon again
        drinkTimer = drinkTime; //reset the drinkTimer variable
        if(perk == 1) //jugg
        {
            maxHp=maxHp*1.5;
            perkNames[perks] = spr_jugg;
            perks++;
        }
        if(perk == 2) //speed
        {
            //The reloading adjustment is done in the reloading code document
            perkNames[perks] = spr_speed;
            perks++;
        }
        if(perk == 3) //stamin-up
        {
            /*
            runningTime = 30;
            runningTimer = runningTime;
            timeBetweenRuns = 60;
            timerBetweenRuns = timeBetweenRuns;
            */
            runningTime = 45;
            timeBetweenRuns = 60;
            perkNames[perks] = spr_stamin;
            perks++;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Knifing
if(keyboard_check_pressed(ord("E")))
{
    knifing = true;
    sprite_index = spr_knife;
    image_speed = 0.5;
}
///Knife Range Testing
if(knifing) //if the knife animation is done
{
    startArmX = x+lengthdir_x(-5, 15+self.image_angle+swingOffset+90);
    startArmY = y+lengthdir_y(-5, 15+self.image_angle+swingOffset+90);
    endArmX = startArmX+lengthdir_x(13, self.image_angle+swingOffset);
    endArmY = startArmY+lengthdir_y(13, self.image_angle+swingOffset);
    if(swingOffset &lt; 140)
        swingOffset += 2; //subtracts the angle by 2 making the hitline of the arm making a swinging motion
    else
    {    
        knifing = false;
        swingOffset = 90;
    }
    if(knifed == false &amp;&amp; knifing) //this reasures that you cant knife more than once per swing
    {
        with(collision_line(startArmX, startArmY, endArmX, endArmY, obj_zombie, 1, 1))
        {
            hp=hp-6;
            obj_player.points+=100;
            other.knifed = true;
        }
    }
}
if(knifing &amp;&amp; image_index = 5) //if the knife animation is done
{
    //sprite_index = weapon[gun+papped, 5];
    knifing = false;
    knifed = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing Variables Needed
draw_self();
//Draw Points
//Test for the current gun
//draw_text(10, 50, weapon[gun+papped, 0]);
//draw_text(20, 70, string(randomGun));
//Draw Ammunition Count
//draw_text(10, 100, string(magazine) + "/" + string(ammo));
//draw_text(100, 100, weapon);
//draw_text(100, 130, firing);
//Showing CeaseFire HitBox
//draw_line(x+lengthdir_x(7, dir+90), y+lengthdir_y(7, dir+90), x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14)); 
//draw_line(x+lengthdir_x(7, dir+270), y+lengthdir_y(7, dir+270),x+lengthdir_x(24, dir-14), y+lengthdir_y(24, dir-14));
/*
//Movement HitBox
draw_rectangle(x, y-player_boundary, (x+player_boundary) + h_movement, y+player_boundary, 1);
draw_rectangle((x-player_boundary) + h_movement, y-player_boundary, x, y+player_boundary, 1);
//Showing Movement Stats.
draw_text(25, 50, "HM");
draw_text(25, 25, h_movement);
draw_text(75, 50, "VM");
draw_text(75, 25, v_movement);
draw_text(125, 50, "LHM");
draw_text(125, 25, lastHMovement);
draw_text(175, 50, "LVM");
draw_text(175, 25, lastVMovement);
//Showing Coordinate Stats.
draw_text(225, 50, "X");
draw_text(225, 25, x);
draw_text(275, 50, "Y");
draw_text(275, 25, y);
draw_text(325, 50, "LX");
draw_text(325, 25, lastX);
draw_text(375, 50, "LY");
draw_text(375, 25, lastY);
/*
//Shows the player boundaries
draw_set_colour(c_black);
draw_rectangle(x-player_speed, y-player_speed, x+player_speed, y+player_speed, 0);
draw_set_color(c_red);

//Shows the player's boundaries, when walking right
if(h_movement &gt; 0) //If trying to move right
{
draw_rectangle(x+player_speed, y-player_speed, x+player_speed+1, y+player_speed, 0); //A one pixel length wall on the right side of the player's boundaries
}
//Shows the player's boundaries, when walking left
if(h_movement &lt; 0) //If trying to move left
{
draw_rectangle(x-player_speed, y-player_speed, x-player_speed-1, y+player_speed, 0); //A one pixel length wall on the right side of the player's boundaries
}
//Shows the player's boundaries, when walking up
if(v_movement &lt; 0)
{
draw_rectangle(x-player_speed, y-player_speed, x+player_speed, y-player_speed-1, 0); //A one pixel length wall on the right side of the player's boundaries
}
//Shows the player's boundaries, when walking down
if(v_movement &gt; 0)
{
draw_rectangle(x-player_speed, y+player_speed, x+player_speed, y+player_speed+1, 0); //A one pixel length wall on the right side of the player's boundaries
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///HUD
//draw_text(200, 340, "Firing Cap: " + string(firingCap));
/*
draw_text(200, 200, "Drinking: " + string(drinking));
draw_text(200, 220, "Time it takes to drink: " + string(drinkTime));
draw_text(200, 240, "Peks owned by the player: " + string(perks));
draw_text(200, 260, "Perk 1: " + string(perkNames[0]));
draw_text(200, 280, "Current Perk that should be displayed: " + string(perkNames[perks]));
/*
draw_text(200, 200, "Time Between Waves: " + string(waveTimer));
draw_text(200, 220, "Zombies Left: " + string(zombiesLeft));
draw_text(200, 240, "Active Zombies: " + string(activeZombies));
draw_text(200, 260, "Max Zombies Active At Once: " + string(maxZombies));
draw_text(200, 280, "Zombies Per Wave: " + string(waveZombies));
draw_text(200, 300, "Firing Cap: " + string(capCounter));
draw_text(200, 320, ": " + string(hp) + "/" + string(maxHp));
draw_text(200, 340, "Gun: " + string(gun) + "SecondGun: " + string(secondGun));
*/
//draw_text(200, 320, "Direction of Shot: " + string(dir));
//draw_text(200, 340, "Direction of Shot 1: " + string(dir1));
//Draw Gun STATS
draw_set_color(c_gray); //set the color to gray
draw_text(((view_xview[0])-(string_width(weapon[gun+papped, 0])+10))+(view_wview[0]), (view_yview[0]+(view_hview[0]))-50, weapon[gun+papped, 0]); //this puts it in the middle
//draw_text(((view_xview[0])-(string_width(weapon[gun+papped, 0])+10)/2)+(view_wview[0]/2), (view_yview[0]+(view_hview[0]/2))-30, weapon[gun+papped, 0]); //this puts it in the middle
//draw_text(room_width-(string_width(weapon[gun+papped, 0])+10), room_height-60, weapon[gun+papped, 0]);
    //Draw Ammunition Count
draw_text(((view_xview[0])-(string_width(string(magazine) + "/" + string(ammo))+10))+(view_wview[0]), (view_yview[0]+(view_hview[0]))-30, string(magazine) + "/" + string(ammo));
//draw_text(room_width-(string_width(string(magazine) + "/" + string(ammo))+10), room_height-40, string(magazine) + "/" + string(ammo));
    //Draw Point Count

draw_text((view_xview[0]), (view_yview[0]+(view_hview[0]))-40, "Points: " + string(points));
//(view_xview[0])
//"Points: " + string(points)
//draw_text((view_xview[0])-(string_width(txt)/2)+(view_wview[0]/2), (view_yview[0]+(view_hview[0]/2)), txt);
//Draw Wave
if(wave &gt; 0)
{
    draw_set_color(c_red); //sets the color to red
    draw_set_font(fnt_wave);
    draw_text((view_xview[0]), (view_yview[0]+(view_hview[0]))-100, string(wave));
    draw_set_font(fnt_default);
    draw_set_color(c_black); //reset the drawing color to black
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Shooting
if(papped == 0) //if the gun is not papped
    shotColor = c_black;
if(papped == 1) //if the gun is not papped
    shotColor = c_red;
if(magazine &gt; 0 &amp;&amp; !ceasefire)
{
    if(weapon[gun+papped, 8] == 0)
    {
        if(gun == 0 )
        {
            if(mouse_check_button_pressed(mb_left))
            {
                draw_line_colour(shotx, shoty, endx, endy, shotColor, shotColor);
                //draw_sprite_ext(spr_fire, random(3), x+lengthdir_x(20, dir-15), y+lengthdir_y(20, dir-15), 1, 1, image_angle, c_white, 1);
                magazine--; //use a bullet
            }
        }
        ///Shooting Remington
        if(gun == 2) //if Remington is equipped
        {
            if(mouse_check_button_pressed(mb_left))
            {
                //draw_text(70, 70, string(shotCoordinate[0])+ ", " + string(shotCoordinate[1]));
                for(i=0; i &lt; array_length_1d(shotCoordinate)-1; i+=2)
                {
                    draw_line_color(shotx, shoty, shotCoordinate[i], shotCoordinate[i+1], shotColor, shotColor);
                }
                magazine--; //use a bullet
            }
        }
    }
    if(weapon[gun+papped, 8] == 1)
    {
        if(capCounter == 0 &amp;&amp; mouse_check_button(mb_left))
        { 
            //show_message("It's drawing");
            draw_line_colour(shotx, shoty, endx, endy, shotColor, shotColor); //draw the shot 
            capCounter = firingCap;
            magazine--;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Box Notification
if(collision_rectangle(obj_mystery_box.x-6, obj_mystery_box.y, obj_mystery_box.x+54, obj_mystery_box.y+20, obj_player, 0, 0) &amp;&amp; cycleGuns&lt;gunsInBox) //if you're next to the box
{
    scr_middleText("Hold [F] for Mystery Box(950)");
    //The below "if" statement shows
}
if(collision_rectangle(obj_mystery_box.x-6, obj_mystery_box.y, obj_mystery_box.x+54, obj_mystery_box.y+20, obj_player, 0, 0)) //if you're next to the box
{
    if(obj_mystery_box.image_index == 10 &amp;&amp; cycleGuns==gunsInBox) //if all the gun animations are done
    {
        scr_middleText("Hold [F] for " + string(weapon[randomGun, 0]));
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///PAP Notification
if(collision_rectangle(obj_pack_a_punch.x-6, obj_pack_a_punch.y, obj_pack_a_punch.x+70, obj_pack_a_punch.y+40, obj_player, 0, 0) &amp;&amp; papStart == false) //if you're next to PAP
{
    scr_middleText("Hold [F] for Pack-A-Punch(5000)");
}
if(collision_rectangle(obj_pack_a_punch.x-6, obj_pack_a_punch.y, obj_pack_a_punch.x+70, obj_pack_a_punch.y+40, obj_player, 0, 0) &amp;&amp; secondPapTimer &gt; 0 &amp;&amp; papStart == true &amp;&amp; papTimer &lt;= 0)
{
    scr_middleText("Hold [F] for " + weapon[papGun+1, 0]);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Perk Management
draw_sprite(perkNames[0], 0, view_xview[0]+ 32, (view_yview[0]+(view_hview[0])-100));
draw_sprite(perkNames[1], 0, view_xview[0]+ 64, (view_yview[0]+(view_hview[0])-100));
draw_sprite(perkNames[2], 0, view_xview[0]+ 96, (view_yview[0]+(view_hview[0])-100));
draw_sprite(perkNames[3], 0, view_xview[0]+ 128, (view_yview[0]+(view_hview[0])-100));
//draw_sprite(spr_jugg, 0, view_xview[0]+ 32*perks, (view_yview[0]+(view_hview[0])-100));
//instance_create(view_xview[0]+ 32*perks, (view_yview[0]+(view_hview[0])-100), perkNames[perks])
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Knife Range Testing
if(knifing) //if the knife animation is done
{
    draw_line(startArmX, startArmY, endArmX, endArmY);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
